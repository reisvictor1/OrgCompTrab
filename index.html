<html>
    <head>
        <title>Hierarquia de Memoria</title>
        <link href="https://unpkg.com/tailwindcss@^1.0/dist/tailwind.min.css" rel="stylesheet">
        <link href="./index.css" rel="stylesheet">
    </head>
    <body class="">
        <header class=" mb-5 flex flex-row justify-center" >
                <img  src="./assets/CpuFreeLogo.png" class="imgLogo mt-5  mx-5" width="200px">
                <h1 class="text-center headerText mx-5 text-4xl  lg:text-6xl">Memória Cache</h1>
        </header>
        <div class="text-3xl container mx-auto">
            <nav class="invisible lg:visible bg-white align-middle flex flex-row justify-around border-solid border-4 border-black nav-d">
                <a class="nav_a" href="#map">Mapeamento</a>
                <a class="nav_a" href="#sub">Política de Substituição</a>
                <a class="nav_a" href="#atual">Atualização</a>
            </nav>
        </div>
        <main class="text-lg container mx-auto bg-white">
            <h3 class="text-5xl flex flex-column lg:flex-row justify-center my-5">Memoria Cache</h3>
            <p class="my-5 text-justify flex flex-column lg:flex-row justify-center text-lg" >Como sabemos a hierarquia de memória existe para que tenhamos um melhor desempenho gerral dos componentes de memória e a memória cache faz parte dessa hierarquia.
                Sendo ela mais rápida que a memória principal, ela é usada para evitar que o processador tenha que “esperar” os dados da memória principal, 
                que é mais lenta que a cpu, consequentemente a cache tem uma capacidade menor,
                logo ela precisa selecionar os dados mais necessários, de modo a gerar uma maior eficiência.
            </p>
            <p class="my-5 text-justify flex flex-column lg:flex-row justify-center text-lg">
                A memória cache possui um método de acesso associativo, 
                ou seja, ela localiza seus dados através de seu conteúdo, 
                e ela geralmente está associada diretamente ao processador para 
                ter uma maior velocidade na transferência de dados para ele.    
            </p>
            <p class="my-5 text-justify flex flex-column lg:flex-row justify-center text-lg"> 
                Ela segue princípios de localidade temporal e espacial, 
                ou seja, se um dado foi utilizado recentemente,
                ele pode ser utilizado novamente no futuro (temporal) e seus vizinhos têm uma grande
                chance de serem utilizados (espacial). Logo a cache é implementada de modo a seguir 
                esses princípios para atingir uma maior eficiência no processamento de dados.
            </p>
            <p class="my-5 text-justify flex flex-column lg:flex-row justify-center text-lg">
                    Como a cache é uma memória que deve manter apenas os dados que podem vir a serem utilizados,
                    ela possui diversas políticas para indicar o que deve ficar ou não na memória além de uma estruturação fixa dos dados.
                    Essas políticas seriam as funções de mapeamento, os algoritmos de substituição e as políticas de escrita.
                    Sua estrutura é definida em blocos, onde cada bloco é um conjunto de palavras e uma palavra é um conjunto de bit que representa um inteiro ou instrução,
                    e contém princípios de HIT(os dados estão na cache) e MISS (os dados não estão na cache).
                    Alguns conceitos que podem ser aplicados em sua estrutura são: Taxa de acertos (proporção de HIT na busca de dados),
                    taxa de falha (1 - taxa de acertos), tempo de acerto (tempo para acessar a cache e descobrir se é um HIT ou MISS),
                    e penalidade por falha (tempo gasto para acessar a memória principal e buscar o que é desejado em caso de MISS).
            </p>
            <br />
            <br />
            <h3 class="text-5xl flex flex-column lg:flex-row justify-center my-5"><a id="map">Funções de Mapeamento</a></h3>
            <p class="my-5 text-justify flex flex-column lg:flex-row justify-center text-lg">
                Como a capacidade de armazenamento da cache é menor do que a da memória principal, é necessário organizar os blocos da memória principal em relação aos blocos da memória cache. Ela é importante pois já estabelece um local para onde os blocos da memória principal devem ser copiados se necessário e acelera a verificação de HIT ou MISS. As funções de mapeamento utilizadas são o mapeamento Direto, Associativo e Associativo por Conjuntos.
            </p>
            <h4 class="text-3xl flex flex-column lg:flex-row justify-center">Mapeamento Direto</h4>
            <p class="my-5 text-justify flex flex-column lg:flex-row justify-center text-lg">
                Pelo Mapeamento direto todos os blocos da memória principal têm uma posição na memória cache,
                porém como a cache é menor do que a principal vários blocos possuem posições repetidas dentro da cache.
                Essa posições são definidas através da equação I = J módulo M, onde I é a posição do bloco na cache,
                J é a posição do bloco na memória principal e M é o número máximo de blocos na cache,
                ou seja o endereço do bloco na cache é o “fim” do endereço do bloco na principal.
            </p>
            <p class="my-5 text-justify flex flex-column lg:flex-row justify-center text-lg">
                Apesar desse método de mapeamento ser simples e  de fácil implementação
                ele sofre em casos onde são necessários referências para blocos diferentes que possuem a mesma posição na cache,
                desse modo sendo necessário continuamente trocar os blocos que estão na cache, desse modo gerando uma alta taxa de falha.
            </p>
            <p class="my-5 text-justify flex flex-column lg:flex-row justify-center text-lg">
                Como diferentes blocos podem ocupar a mesma posição na cache é necessário utilizar tags para identificar o bloco utilizado.
                Essa tag é a parte endereço que difere entre os blocos que ocupam o mesmo espaço na cache,
                ou seja o início do endereço na memória principal.
            </p>
            <p class="my-5 text-justify flex flex-column lg:flex-row justify-center text-lg">
                O endereço na cache é dividido em campos, cada campo é utilizado para representar uma parte do bloco e para facilitar a busca e descobrir se temos um caso de HIT ou MISS.
                Se a arquitetura for endereçada a byte utilizaremos um byte offset para indicar o tamanho de uma palavra,
                se os blocos tiverem mais do que uma palavra utilizaremos um word offset para indicar cada palavra,
                no caso do mapeamento direto utilizaremos o index para indicar o valor I da posição do bloco atual, e por fim a tag.
            </p>
            <h4 class="text-3xl flex flex-column lg:flex-row justify-center">Mapeamento Associativo</h4>
            <p class="my-5 text-justify flex flex-column lg:flex-row justify-center text-lg">
                    Diferente do mapeamento direto o associativo não possui posições fixas, logo qualquer posição disponível pode ser utilizada.
                    Se não existirem posições disponíveis utilizaremos os algoritmos de substituição para estabelecer o bloco a ser substituído.
                    Desse modo o mapeamento associativo evita as desvantagens do direto.
            </p>
            <p class="my-5 text-justify flex flex-column lg:flex-row justify-center text-lg">
                O endereço da cache para esse método de mapeamento é similar ao do direto. Ela
                mantém o byte offset e o word offset porém não temos mais o index e dessa vez a tag é o endereço do bloco na memória principal porém desconsiderando os bits de word offset,
                ou seja os bits que diferenciam os endereços de palavras do mesmo bloco, ou o endereço original do bloco caso o ele possua apenas uma palavra.    
            </p>
            <p class="my-5 text-justify flex flex-column lg:flex-row justify-center text-lg">
                Apesar desse método de mapeamento ter mais opções para a inserção de blocos na cache ele possui uma implementação mais complexa
                e temos uma maior dificuldade em comparar as tags dos blocos durante a busca pelos dados desejados.
            </p>
            <br />
            <br />
            <h3 class="text-5xl flex flex-column lg:flex-row justify-center my-5"><a id="sub">Políticas de Substituição</a></h3>
            <p class="my-5 text-justify flex flex-column lg:flex-row justify-center text-lg">
                Quando um bloco é trazido para a cache e não existe espaço, ocorre uma falha de conflito(write-miss). Para resolver este problema é utilizado algoritmos de substituição para substituir,
                em teoria, o bloco que tem a menor probabilidade de ser utilizado novamente. Isto serve somente para o mapeamento associativo e associativo por conjunto,
                visto que o mapeamento direto substitui o bloco diretamente.
                Conforme evoluíram as caches, existiram diversos tipos de algoritmos sendo que alguns deles são:
            </p>
            <h4 class="text-3xl flex flex-column lg:flex-row justify-center">FIFO</h4>
            <p class="my-5 text-justify flex flex-column lg:flex-row justify-center text-lg">
                Este algoritmo é praticamente uma fila em que o primeiro bloco a ser trazido para a cache será o primeiro bloco a ser substituído da cache.
                Em cada linha existe um contador(bits para a contagem) que indicam o momento em que foram inseridos na cache. Toda vez que um bloco é inserido,
                o contador é incrementado para todos os blocos (com bit de validade igual a 1). O bloco que tiver o maior valor no contador, (maior tempo na cache), será substituído.
            </p>
            <p class="my-5 text-justify flex flex-column lg:flex-row justify-center text-lg">
                O maior problema deste algoritmo é que nem sempre o bloco com maior tempo na cache tem menos probabilidade de ser utilizado.
            </p>
            <h3 class="text-5xl flex flex-column lg:flex-row justify-center my-5"><a id="atual">Políticas de Atualização</a></h3>
           
        </main>
        <footer class="flex flex-row justify-center lg:justify-start ml-3 text-sm">
            Criado por João Nagasava, Matheus Rigato, Victor Reis e Vinicius Carvalho - ICMC USP 
        </footer>
    </body>


</html>